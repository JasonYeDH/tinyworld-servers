#ifndef _COMMON_MESSAGE_H
#define _COMMON_MESSAGE_H

#include "tinyworld.h"
#include <zmq.hpp>
#include <map>

////////////////////////////////////////////////////////////
//
// MessageHeader
// 
// +-------------+-------------+
// |MessageHeader| Body        |
// +-------------+-------------+
//      4bytes       mh.size
//
////////////////////////////////////////////////////////////

#pragma pack(1)

struct MessageHeader
{
	MessageHeader()
	{
		size = 0;
		zip = 0;
		encrypt = 0;
		checksum = 0;
		reserved = 0;
	}

	uint32 size:24;            // message body size
	uint32 zip:1;              // message is zipped
	uint32 encrypt:1;          // message is encrypted
	uint32 checksum:1;         // checksum
	uint32 reserved:5;

	union {
		struct {
			uint8 type_first;  // first type 
			uint8 type_second; // second type
		};
		uint16 type;           // message type;
	};
};

#pragma pack()


////////////////////////////////////////////////////////////
//
// Message Handler Interface
//
////////////////////////////////////////////////////////////
struct IMsgHandler
{
public:
	virtual bool process(const void* msg, const uint32 size) = 0;

	virtual uint32 msgtype() const = 0;

public:
	void* arg_;
};


////////////////////////////////////////////////////////////
//
// Concrete Message Handler, MSG is the specified message.
// Notice! MSG is the class generated by protoc(protobuf 
// compiler).
//
////////////////////////////////////////////////////////////
template <typename MSG>
struct MsgHandler : public IMsgHandler
{
public:
	virtual uint32 msgtype() const
	{
		return (MSG::MSGTYPE_FIRST << 16) + MSG::MSGTYPE_SECOND;
	}

	virtual bool process(const void* msg, const uint32 size)
	{
		MSG req;
		if (!req.ParseFromArray(msg, size))
			return false;

		//std::cout << __PRETTY_FUNCTION__ << std::endl;
        //std::cout << req.DebugString() << std::endl;

        this->handle(req);
	}

	template <typename T>
	const T& getArg()
	{
		return *reinterpret_cast<T*>(this->arg_);
	} 

public:
	void handle(const MSG& msg)
	{
		std::cout << __PRETTY_FUNCTION__ << std::endl;
	}
};

////////////////////////////////////////////////////////////
//
// Message Dispatcher.
// Dispatch messages to the specified handler which you 
// should register on the beging.
//
////////////////////////////////////////////////////////////
template <int ID>
class MsgDispatcher 
{
public:
	static MsgDispatcher& instance()
	{
		static MsgDispatcher dispatcher;
		return dispatcher;
	}

	bool regHandler(IMsgHandler* handler)
	{
		if (!handler) return false;

		if (handlers_.find(handler->msgtype()) != handlers_.end())
		{
			std::cerr << "[FATAL] " << __PRETTY_FUNCTION__ 
			          << ": (" << (handler->msgtype() >> 16) 
			          << "," << (handler->msgtype() & 0xffff)
			          << ")" << std::endl;

			return false;
		}

		handlers_.insert(std::make_pair(handler->msgtype(), handler));
		return true;
	}

	bool dispatch(void* msg, uint32 msgsize, void* arg = NULL)
	{
		if (!msg || msgsize < sizeof(MessageHeader))
			return false;

		MessageHeader* mh = reinterpret_cast<MessageHeader*>(msg);
		if (mh->size + sizeof(MessageHeader) > msgsize)
			return false;

		HandlerMap::iterator it = handlers_.find(mh->type);
		if (it == handlers_.end() || NULL == it->second)
			return false;

		it->second->arg_ = arg;
		return it->second->process(mh + 1, mh->size);
	}

	template <typename T>
	bool dispatchWithArg(void* msg, uint32 msgsize, T* arg)
	{
		//std::cout << __PRETTY_FUNCTION__ << std::endl;
		return this->dispatch(msg, msgsize, (void*)arg);
	}

private:
	MsgDispatcher()
	{
	}

	~MsgDispatcher()
	{
		for (HandlerMap::iterator it = handlers_.begin(); it != handlers_.end(); ++ it)
			if (it->second)
				delete it->second;
		handlers_.clear();
	}

	typedef std::map<uint16, IMsgHandler*> HandlerMap;
	HandlerMap handlers_;
};


template <int ID, typename MSG>
struct MsgHandlerRegHelper
{
	MsgHandlerRegHelper()
	{
		MsgDispatcher<ID>::instance().regHandler(new MsgHandler<MSG>);
	}	
};

#define DefMsgHandler(DISPATCHER, PACKAGE, MSGTYPE, MSG) \
	MsgHandlerRegHelper<DISPATCHER, PACKAGE::MSGTYPE> __##MSGTYPE##_reg; \
	template <> void MsgHandler<PACKAGE::MSGTYPE>::handle(const PACKAGE::MSGTYPE& MSG)

#define DefMsgHandler2(DISPATCHER, MSGTYPE, MSG) \
	template <> void MsgHandler<MSGTYPE>::handle(const MSGTYPE& MSG)



template <typename MSG>
inline void sendmsg(const MSG& msg, zmq::socket_t& socket)
{
    //std::cout << __PRETTY_FUNCTION__ << std::endl;
    //std::cout << msg.DebugString() << std::endl;

    MessageHeader mh;
    mh.size = msg.ByteSize();
    mh.type = (uint16)((MSG::MSGTYPE_FIRST << 16) + MSG::MSGTYPE_SECOND);

    zmq::message_t req(sizeof(MessageHeader) + mh.size);
    memcpy(req.data(), &mh, sizeof(mh));
    msg.SerializeToArray(static_cast<MessageHeader*>(req.data()) + 1, mh.size);
    socket.send(req);
}


//  Receive 0MQ string from socket and convert into string
static std::string
s_recv (zmq::socket_t & socket) {

    zmq::message_t message;
    socket.recv(&message);

    return std::string(static_cast<char*>(message.data()), message.size());
}

//  Convert string to 0MQ string and send to socket
static bool
s_send (zmq::socket_t & socket, const std::string & string) {

    zmq::message_t message(string.size());
    memcpy (message.data(), string.data(), string.size());

    bool rc = socket.send (message);
    return (rc);
}

//  Sends string as 0MQ string, as multipart non-terminal
static bool
s_sendmore (zmq::socket_t & socket, const std::string & string) {

    zmq::message_t message(string.size());
    memcpy (message.data(), string.data(), string.size());

    bool rc = socket.send (message, ZMQ_SNDMORE);
    return (rc);
}



#endif // _COMMON_MESSAGE_H